<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>

<body>
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <script>
    /*
     函数就是一个闭包
     闭包:函数可以使用函数之外定义的变量

     内部函数的作用域链仍然保持着对父函数活动对象的引用，这就是闭包(closure)

     函数嵌套函数，子函数引用父函数的参数或者变量，并且子函数还被外界所引用，这个时候子函数作用域链仍然保持着对父函数活动对象的引用，父函数的参数和变量就不会被浏览器垃圾回收机制给回收  ，此时打印父函数的函数返回值，会发现返回值下面有一个scopes，这个scopes下面有个closure（闭包）==》整个父级都形成了闭包环境

   */

    /*
      全局的活动对象在关闭浏览器之后才会被销毁
    */
    // function fn() {
    //   var a = 10;

    //   function fn2() {
    //     a++;
    //     console.log(a);
    //   }

    //   function fn3() {}
    //   console.dir(fn3);//有Global 闭包
    //   return fn2;
    // }
    // var f = fn();
    // console.dir(f);//Global 闭包

    // f();//11
    // f();//12


    // function fn1(a){
    //   function fn(){
    //     a++;
    //     console.log(a);
    //   }
    //   return fn;
    // }
    // fn1(1)();//2
    // fn1(1)();//2
    // console.dir(fn1(1));
    // var f=fn1(1);
    // f();//2
    // f();//3
    // console.dir(f);


    const btns = document.querySelectorAll('button');

    // for(var i=0;i<btns.length;i++){
    //   btns[i].index=i;//自定义 存储所有值 结合this
    // btns[i].onclick=function(){
    //   alert(this.index);
    // }
    // }

//被函数抱起来
    // for (var i = 0; i < btns.length; i++) {
    //   function fn(a) {
    //     btns[a].onclick = function () {
    //       alert(a);
    //     }
    //   }
    //   fn(i);//存储i的所有值
    // }

//自执行函数
    // for (var i = 0; i < btns.length; i++) {
    //   (function(a) {
    //     btns[a].onclick = function () {
    //       alert(a);
    //     }
    //   })(i);//存储i的所有值
    // }



//第三种
for(var i= 0;i<6;i++){
  function fn(i){
    setTimeout(function(){//函数自带声明
      console.log(i)
    },100);
  }
  fn(i);//存储i的所有值
}
  

  </script>
</body>

</html>